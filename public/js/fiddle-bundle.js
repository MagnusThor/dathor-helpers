/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/ExampleApp/Components/Actions/AddToCartAction.js":
/*!***************************************************************!*\
  !*** ./dist/ExampleApp/Components/Actions/AddToCartAction.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddToCartAction: () => (/* binding */ AddToCartAction)\n/* harmony export */ });\n/* harmony import */ var _UI_UIComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../UI/UIComponent */ \"./dist/UI/UIComponent.js\");\n// src/UI/Components/Actions/AddToCartAction.ts\n\n/**\n * A component representing an \"Add to Cart\" button.\n * It publishes an event when clicked.\n */\nclass AddToCartAction extends _UI_UIComponent__WEBPACK_IMPORTED_MODULE_0__.UIComponentBase {\n    constructor(properties) {\n        super({\n            ...properties,\n            id: properties.id || `add-to-cart-${properties.productId}`, // Ensure a unique ID\n            name: properties.name || 'AddToCartAction',\n            template: (component) => {\n                const props = component.properties;\n                const label = props.label || \"Add to Cart\";\n                const buttonClasses = props.buttonClasses || \"bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200\";\n                return /*html*/ `\r\n                    <button class=\"${buttonClasses}\" data-event-click=\"handleAddToCart\">\r\n                        ${label}\r\n                    </button>\r\n                `;\n            },\n            eventHandlers: {\n                click: (event) => {\n                    const target = event.target;\n                    if (target.dataset.eventClick === 'handleAddToCart') {\n                        this.handleAddToCart(event);\n                    }\n                }\n            }\n        });\n        // Set default quantity if not provided\n        if (this.properties.quantity === undefined || this.properties.quantity === null) {\n            this.properties.quantity = 1;\n        }\n    }\n    /**\n     * Handles the click event for the \"Add to Cart\" button.\n     * Publishes an 'addToCart' event via the event bus.\n     */\n    handleAddToCart(event) {\n        event.preventDefault(); // Prevent default button behavior if it's inside a form\n        console.log(`[${this.properties.id}] Adding product ${this.properties.productId} (Qty: ${this.properties.quantity}) to cart.`);\n        // Publish an event that other parts of the application (e.g., a CartService) can listen to\n        this.publish('addToCart', {\n            productId: this.properties.productId,\n            quantity: this.properties.quantity\n        });\n        // Optionally, provide visual feedback\n        alert(`Added ${this.properties.quantity} of Product ${this.properties.productId} to cart!`);\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/ExampleApp/Components/Actions/AddToCartAction.js?");

/***/ }),

/***/ "./dist/ExampleApp/Components/HomePageComponent.js":
/*!*********************************************************!*\
  !*** ./dist/ExampleApp/Components/HomePageComponent.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HomePageComponent: () => (/* binding */ HomePageComponent)\n/* harmony export */ });\n/* harmony import */ var _UI_Components_Core_PageComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UI/Components/Core/PageComponent */ \"./dist/UI/Components/Core/PageComponent.js\");\n\nclass HomePageComponent extends _UI_Components_Core_PageComponent__WEBPACK_IMPORTED_MODULE_0__.PageComponent {\n    constructor(properties) {\n        super({\n            ...properties, // Inherit base properties like id, path, router\n            // Provide the template function directly in properties\n            template: (component) => {\n                // 'component' here is the HomePageComponent instance\n                const { welcomeMessage, clickCount } = component.properties.state;\n                // Access state\n                const router = component.properties.router; // Access router from properties\n                return /*html*/ `\r\n                    <div class=\"home-page p-6 bg-white shadow rounded-lg mb-6\">\r\n                        <h1 class=\"text-3xl font-bold text-gray-900 mb-4\">${welcomeMessage}</h1>\r\n                        <p class=\"text-gray-700 mb-4\">\r\n                            Welcome to your single-page application built with a custom framework!\r\n                            This is the home page.\r\n                        </p>\r\n                        <p class=\"text-gray-700 mb-4\">\r\n                            You have clicked the button <span class=\"font-bold text-blue-600\">${clickCount}</span> times.\r\n                        </p>\r\n                        <button class=\"bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200\"\r\n                                data-event-click=\"handleClick\">\r\n                            Click Me!\r\n                        </button>\r\n                        \r\n                        <div class=\"mt-8\">\r\n                            <h2 class=\"text-xl font-semibold mb-3 text-gray-800\">Explore Further:</h2>\r\n                            <ul class=\"list-disc list-inside text-blue-600 space-y-2\">\r\n                                <li>\r\n                                    <a href=\"#/products/123\" class=\"hover:underline\">Go to Product 123 (via hash link)</a>\r\n                                </li>\r\n                                <li>\r\n                                    <button class=\"text-blue-600 hover:underline cursor-pointer focus:outline-none\" \r\n                                            data-event-click=\"goToProductPage\">\r\n                                        Go to Product 456 (programmatic)\r\n                                    </button>\r\n                                </li>\r\n                                <li>\r\n                                    <a href=\"#/about\" class=\"hover:underline\">Go to About Us (will show 404 if not defined)</a>\r\n                                </li>\r\n                            </ul>\r\n                        </div>\r\n                    </div>\r\n                `;\n            },\n            state: {\n                welcomeMessage: properties.state?.welcomeMessage || \"Hello from Home Page!\",\n                clickCount: properties.state?.clickCount || 0\n            },\n            // Define event handlers for elements within this component's template\n            eventHandlers: {\n                // 'click' is the DOM event name. This handler will be applied to the component's root.\n                // We assume _applyEventHandlers is smart enough to delegate based on data-event-click\n                // or you apply listeners directly in render for specific elements.\n                // For simplicity here, we'll map a generic click to a method.\n                // In a real app, you might parse data-event-click to find the method name.\n                // For now, we'll assume a delegated click that checks event.target.\n                click: (event) => {\n                    const target = event.target;\n                    if (target.dataset.eventClick === 'handleClick') {\n                        this.handleClick(event);\n                    }\n                    else if (target.dataset.eventClick === 'goToProductPage') {\n                        this.goToProductPage(event);\n                    }\n                }\n            }\n        });\n    }\n    // Event handler method for the button click\n    handleClick(event) {\n        console.log('Home Page Button clicked!', event);\n        // Update the component's state, which will trigger a re-render if observed.\n        this.updateState({ clickCount: (this.properties?.state.clickCount || 0) + 1 });\n    }\n    // Event handler for programmatic navigation\n    goToProductPage(event) {\n        event.preventDefault(); // Prevent default link behavior if applicable\n        console.log('Navigating programmatically to Product 456...');\n        // Use the router instance passed in properties to navigate\n        this.properties.router.navigate('/products/456');\n    }\n    // Lifecycle method called when the page component is entered\n    async onEnter(prevProps) {\n        await super.onEnter(prevProps); // Call base class onEnter\n        console.log(`[HomePageComponent] onEnter: current path is ${this.properties.path}`);\n        // You could fetch initial data here, for example\n        // this.updateState({ isLoading: true });\n        // const data = await fetchDataForHome();\n        // this.updateState({ isLoading: false, data: data });\n    }\n    // Lifecycle method called when the page component is left\n    onLeave() {\n        super.onLeave(); // Call base class onLeave\n        console.log(`[HomePageComponent] onLeave: path was ${this.properties.path}`);\n        // Clean up subscriptions or resources here\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/ExampleApp/Components/HomePageComponent.js?");

/***/ }),

/***/ "./dist/ExampleApp/Components/ProductDetailsComponent.js":
/*!***************************************************************!*\
  !*** ./dist/ExampleApp/Components/ProductDetailsComponent.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProductDetailComponent: () => (/* binding */ ProductDetailComponent)\n/* harmony export */ });\n/* harmony import */ var _UI_Components_Core_PageComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UI/Components/Core/PageComponent */ \"./dist/UI/Components/Core/PageComponent.js\");\n/* harmony import */ var _Actions_AddToCartAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actions/AddToCartAction */ \"./dist/ExampleApp/Components/Actions/AddToCartAction.js\");\n\n\nclass ProductDetailComponent extends _UI_Components_Core_PageComponent__WEBPACK_IMPORTED_MODULE_0__.PageComponent {\n    // Declare a private property to hold the instance of the AddToCartAction component\n    _addToCartComponent = null;\n    constructor(properties) {\n        super({\n            ...properties, // Inherit base properties like id, path, router, routeParams\n            // Provide the template function directly in properties\n            template: (component) => {\n                // Safely access state properties using non-null assertion as state is initialized\n                const { productId, productName, productDescription, loading, error } = component.properties.state;\n                const router = component.properties.router;\n                if (loading) {\n                    return /*html*/ `\r\n                        <div class=\"product-detail-page p-6 bg-white shadow rounded-lg text-center\">\r\n                            <p class=\"text-gray-600 text-lg\">Loading product details for ID: ${productId}...</p>\r\n                            <div class=\"animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto mt-4\"></div>\r\n                        </div>\r\n                    `;\n                }\n                if (error) {\n                    return /*html*/ `\r\n                        <div class=\"product-detail-page p-6 bg-white shadow rounded-lg text-center text-red-600\">\r\n                            <h1 class=\"text-2xl font-bold mb-4\">Error Loading Product</h1>\r\n                            <p>${error}</p>\r\n                            <button class=\"mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200\"\r\n                                    data-event-click=\"goBack\">\r\n                                Go Back\r\n                            </button>\r\n                        </div>\r\n                    `;\n                }\n                if (!productId) {\n                    return /*html*/ `\r\n                        <div class=\"product-detail-page p-6 bg-white shadow rounded-lg text-center\">\r\n                            <h1 class=\"text-2xl font-bold text-gray-900 mb-4\">Product Not Found</h1>\r\n                            <p class=\"text-gray-700\">No product ID was provided or found in the URL.</p>\r\n                            <button class=\"mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200\"\r\n                                    data-event-click=\"goBack\">\r\n                                Go Back\r\n                            </button>\r\n                        </div>\r\n                    `;\n                }\n                return /*html*/ `\r\n                    <div id=\"${component.properties.id}\" class=\"product-detail-page p-6 bg-white shadow rounded-lg mb-6\">\r\n                        <h1 class=\"text-3xl font-bold text-gray-900 mb-4\">Product Details for ID: ${productId}</h1>\r\n                        <h2 class=\"text-2xl font-semibold text-gray-800 mb-2\">${productName}</h2>\r\n                        <p class=\"text-gray-700 mb-4\">${productDescription}</p>\r\n\r\n                        <div id=\"add-to-cart-container-${productId}\" class=\"my-6\">\r\n                            </div>\r\n                        \r\n                        <button class=\"bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded transition-colors duration-200\"\r\n                                data-event-click=\"goBack\">\r\n                            Go Back\r\n                        </button>\r\n                    </div>\r\n                `;\n            },\n            state: {\n                productId: null,\n                productName: '',\n                productDescription: '',\n                loading: true, // Start in a loading state\n                error: undefined\n            }, // Assert initial state type\n            // Define event handlers for elements within this component's template\n            eventHandlers: {\n                click: (event) => {\n                    const target = event.target;\n                    if (target.dataset.eventClick === 'goBack') {\n                        this.goBack();\n                    }\n                }\n            }\n        });\n    }\n    // Lifecycle method called when the page component is entered\n    async onEnter(prevProps) {\n        await super.onEnter(prevProps); // Call base class onEnter\n        console.log(`[ProductDetailComponent] onEnter: current path is ${this.properties?.path}`);\n        const productId = this.properties.routeParams.id || null;\n        console.log(`[ProductDetailComponent] Product ID from URL parameters: ${productId}`);\n        this.updateState({ productId, loading: true, error: undefined });\n        if (productId) {\n            try {\n                const productData = await this.fetchProductData(productId);\n                this.updateState({\n                    productName: productData.name,\n                    productDescription: productData.description,\n                    loading: false,\n                    error: undefined\n                });\n                // --- CRITICAL STEP: Create and render the AddToCartAction after product data is loaded ---\n                this.createAddToCartComponent(productId);\n            }\n            catch (err) {\n                console.error(\"Failed to fetch product data:\", err);\n                this.updateState({\n                    error: `Could not load product with ID: ${productId}. ${err instanceof Error ? err.message : String(err)}`,\n                    loading: false\n                });\n            }\n        }\n        else {\n            this.updateState({ loading: false, error: \"No product ID found in URL for details.\" });\n        }\n    }\n    // Lifecycle method called when the page component is left\n    onLeave() {\n        super.onLeave();\n        console.log(`[ProductDetailComponent] onLeave: path was ${this.properties?.path}`);\n        // --- CRITICAL STEP: Dispose of the child component when the parent leaves ---\n        if (this._addToCartComponent) {\n            this._addToCartComponent.dispose();\n            this._addToCartComponent = null; // Clear reference\n        }\n    }\n    // --- Private Helper Methods ---\n    // Simulates an asynchronous API call to fetch product data\n    async fetchProductData(id) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                if (id === '123') {\n                    resolve({ name: 'Awesome Gadget 123', description: 'A highly advanced and essential gadget for modern life. It does everything!' });\n                }\n                else if (id === '456') {\n                    resolve({ name: 'Super Widget 456', description: 'This is the super widget 456, known for its incredible durability and efficiency.' });\n                }\n                else if (id === 'abc') {\n                    resolve({ name: 'Mystery Item ABC', description: 'An enigmatic item with unknown properties and a mysterious past. Buyer beware!' });\n                }\n                else {\n                    reject(new Error('Product not found for this ID.')); // Simulate 404 or other error\n                }\n            }, 700); // 700ms delay\n        });\n    }\n    /**\n     * Creates, adds, and renders the AddToCartAction component.\n     * @param productId The ID of the product to associate with the AddToCart button.\n     */\n    async createAddToCartComponent(productId) {\n        // Ensure the main component's element exists and is rendered\n        if (!this._element) {\n            console.error(`[ProductDetailComponent] Cannot create AddToCartAction: Main component element not found.`);\n            return;\n        }\n        // Find the specific container div within this component's rendered HTML\n        const containerElement = this._element.querySelector(`#add-to-cart-container-${productId}`);\n        if (containerElement) {\n            // Dispose of any existing AddToCartComponent instance if this is a re-render\n            if (this._addToCartComponent) {\n                this._addToCartComponent.dispose();\n            }\n            this._addToCartComponent = new _Actions_AddToCartAction__WEBPACK_IMPORTED_MODULE_1__.AddToCartAction({\n                id: `add-to-cart-button-${productId}`, // Unique ID for the button instance\n                productId: productId,\n                quantity: 1, // Default quantity\n                label: `Add ${productId} to Cart`,\n                componentInstance: this // Pass current component for context in event handlers\n            });\n            // Add the AddToCartAction as a child component of ProductDetailComponent.\n            // This ensures it benefits from the parent's lifecycle management (e.g., disposal).\n            this.addChild(this._addToCartComponent);\n            // Render the AddToCartAction component and append its result to the container\n            const renderResult = await this._addToCartComponent.render();\n            if (renderResult.result) {\n                // Clear the container before appending, just in case\n                containerElement.innerHTML = '';\n                containerElement.appendChild(renderResult.result);\n                console.log(`[ProductDetailComponent] AddToCartAction component mounted for product ${productId}.`);\n            }\n            else {\n                console.warn(`[ProductDetailComponent] AddToCartAction render resulted in no element.`);\n            }\n        }\n        else {\n            console.error(`[ProductDetailComponent] Container #add-to-cart-container-${productId} not found for AddToCartAction.`);\n        }\n    }\n    // Method to navigate back using the router\n    goBack() {\n        this.properties.router.goBack(); // Assumes your Router class has a `goBack` method\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/ExampleApp/Components/ProductDetailsComponent.js?");

/***/ }),

/***/ "./dist/ExampleApp/MyApp.js":
/*!**********************************!*\
  !*** ./dist/ExampleApp/MyApp.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MyApp: () => (/* binding */ MyApp)\n/* harmony export */ });\n/* harmony import */ var _UI_Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/Application/ApplicationManager */ \"./dist/UI/Application/ApplicationManager.js\");\n/* harmony import */ var _UI_Components_Core_RootUIComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/Components/Core/RootUIComponent */ \"./dist/UI/Components/Core/RootUIComponent.js\");\n/* harmony import */ var _UI_Router_Router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UI/Router/Router */ \"./dist/UI/Router/Router.js\");\n/* harmony import */ var _Components_HomePageComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Components/HomePageComponent */ \"./dist/ExampleApp/Components/HomePageComponent.js\");\n/* harmony import */ var _Components_ProductDetailsComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Components/ProductDetailsComponent */ \"./dist/ExampleApp/Components/ProductDetailsComponent.js\");\n\n\n\n\n\nclass MyApp {\n    appManager;\n    router;\n    constructor() {\n        const appRoutes = [\n            {\n                path: '/',\n                component: _Components_HomePageComponent__WEBPACK_IMPORTED_MODULE_3__.HomePageComponent,\n                defaultProps: { id: 'home-page', path: '/', router: null }\n            },\n            {\n                path: '/products/:id',\n                component: _Components_ProductDetailsComponent__WEBPACK_IMPORTED_MODULE_4__.ProductDetailComponent,\n                defaultProps: { id: 'product-detail-page', path: '/products/:id', router: null }\n            },\n        ];\n        this.router = new _UI_Router_Router__WEBPACK_IMPORTED_MODULE_2__.Router(appRoutes, '#main-content');\n        appRoutes.forEach(route => {\n            if (route.defaultProps) {\n                route.defaultProps.router = this.router;\n            }\n            else {\n                route.defaultProps = { router: this.router, id: 'auto-id-' + Math.random().toString(36).substring(2, 9), path: route.path };\n            }\n        });\n        const appRootComponent = new _UI_Components_Core_RootUIComponent__WEBPACK_IMPORTED_MODULE_1__.RootUIComponent({ id: 'app-root' });\n        this.appManager = new _UI_Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_0__.ApplicationManager(appRootComponent, this.router, 'body');\n    }\n    /**\n     * Runs the application by starting the ApplicationManager.\n     * The ApplicationManager will handle rendering the root component and starting the router.\n     */\n    async run() {\n        await this.appManager.start();\n        console.log(\"Application is fully started.\");\n    }\n}\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n    console.log(\"DOM Content Loaded. Initializing MyApp...\");\n    const app = new MyApp();\n    await app.run();\n});\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/ExampleApp/MyApp.js?");

/***/ }),

/***/ "./dist/UI/Application/ApplicationManager.js":
/*!***************************************************!*\
  !*** ./dist/UI/Application/ApplicationManager.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApplicationManager: () => (/* binding */ ApplicationManager),\n/* harmony export */   eventBus: () => (/* binding */ eventBus),\n/* harmony export */   globalState: () => (/* binding */ globalState)\n/* harmony export */ });\n/* harmony import */ var _helpers_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/all */ \"./dist/helpers/all.js\");\n/* harmony import */ var _EventBus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventBus */ \"./dist/UI/Application/EventBus.js\");\n/* harmony import */ var _GlobalStateStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GlobalStateStore */ \"./dist/UI/Application/GlobalStateStore.js\");\n\n\n\nconst eventBus = _EventBus__WEBPACK_IMPORTED_MODULE_1__.EventBus.getInstance();\nconst globalState = new _GlobalStateStore__WEBPACK_IMPORTED_MODULE_2__.GlobalStateStore({\n// Initial global state properties can go here\n});\nclass ApplicationManager {\n    rootComponent;\n    targetElement;\n    router; // NEW: Private property to hold the Router instance\n    /**\n     * @param rootComponent The top-level UI component of your application.\n     * @param router The Router instance responsible for navigation.\n     * @param targetSelector The CSS selector for the DOM element where the app should be mounted.\n     */\n    constructor(rootComponent, router, targetSelector = 'body') {\n        this.rootComponent = rootComponent;\n        this.router = router; // NEW: Assign the router instance\n        const target = _helpers_all__WEBPACK_IMPORTED_MODULE_0__.$D.get(targetSelector);\n        if (!target) {\n            throw new Error(`Target element with selector '${targetSelector}' not found in the DOM.`);\n        }\n        this.targetElement = target;\n    }\n    /**\n     * Renders the root component, mounts it to the target DOM element, and then starts the router.\n     */\n    async start() {\n        if (!this.rootComponent.render) {\n            console.error(\"Application Manager: Root component does not have a render method defined.\");\n            return;\n        }\n        try {\n            console.log(\"Application Manager: Starting render process for root component...\");\n            // Call the root component's render, which recursively renders its children\n            const renderResult = await this.rootComponent.render();\n            if (renderResult.result) {\n                // Clear any existing content in the target element (e.g., initial loading spinner)\n                this.targetElement.innerHTML = '';\n                // Append the fully rendered component tree to the actual DOM\n                this.targetElement.appendChild(renderResult.result);\n                console.log(\"Application Manager: Root component rendered and mounted to DOM.\");\n                // NEW: Start the router *after* the root component (containing the router outlet)\n                // has been successfully mounted to the DOM.\n                console.log(\"Application Manager: Starting router...\");\n                this.router.start();\n                console.log(\"Application Manager: Router started successfully.\");\n            }\n            else {\n                console.warn(\"Application Manager: Root component render result was undefined. Nothing mounted.\");\n            }\n        }\n        catch (error) {\n            console.error(\"Application Manager: Error during rendering or router startup:\", error);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Application/ApplicationManager.js?");

/***/ }),

/***/ "./dist/UI/Application/EventBus.js":
/*!*****************************************!*\
  !*** ./dist/UI/Application/EventBus.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventBus: () => (/* binding */ EventBus),\n/* harmony export */   eventBus: () => (/* binding */ eventBus)\n/* harmony export */ });\n// eventBus.ts (Updated)\nclass EventBus {\n    // A map where the key is the topic name (string)\n    // and the value is an array of SubscriberInfo objects for that topic.\n    subscribers = new Map();\n    static instance;\n    constructor() { }\n    static getInstance() {\n        if (!EventBus.instance) {\n            EventBus.instance = new EventBus();\n        }\n        return EventBus.instance;\n    }\n    /**\n     * Subscribes a callback function to a specific topic.\n     * The `subscriberId` is now required to enable targeted messages.\n     * @param topic The name of the event topic.\n     * @param callback The function to be called when the event is published.\n     * @param subscriberId The ID of the component/entity that is subscribing.\n     */\n    subscribe(topic, callback, subscriberId) {\n        if (!this.subscribers.has(topic)) {\n            this.subscribers.set(topic, []);\n        }\n        // Add the subscriber with their ID to the list for this topic\n        this.subscribers.get(topic)?.push({ id: subscriberId, callback });\n        console.log(`[EventBus] Component \"${subscriberId}\" subscribed to topic: \"${topic}\"`);\n    }\n    /**\n     * Unsubscribes a specific callback from a topic.\n     * The `subscriberId` is now required to correctly identify the subscription to remove.\n     * @param topic The name of the event topic.\n     * @param callback The original callback function to remove.\n     * @param subscriberId The ID of the component/entity that subscribed.\n     */\n    unsubscribe(topic, callback, subscriberId) {\n        const topicSubscribers = this.subscribers.get(topic);\n        if (topicSubscribers) {\n            // Filter out the specific subscription by matching both callback and ID\n            this.subscribers.set(topic, topicSubscribers.filter(sub => !(sub.callback === callback && sub.id === subscriberId)));\n            console.log(`[EventBus] Component \"${subscriberId}\" unsubscribed from topic: \"${topic}\"`);\n        }\n    }\n    /**\n     * Publishes data to a specific topic for ALL subscribers of that topic.\n     * This is your existing broadcast functionality.\n     * @param topic The name of the event topic.\n     * @param data The data to be passed to the subscribers.\n     */\n    publish(topic, data) {\n        const topicSubscribers = this.subscribers.get(topic);\n        if (topicSubscribers) {\n            console.log(`[EventBus] Publishing (broadcast) to topic: \"${topic}\"`, data);\n            // Iterate over a copy to prevent issues if subscribers unsubscribe themselves during iteration\n            [...topicSubscribers].forEach(sub => {\n                try {\n                    sub.callback(data);\n                }\n                catch (e) {\n                    console.error(`[EventBus] Error in subscriber for topic \"${topic}\" (ID: ${sub.id}):`, e);\n                }\n            });\n        }\n        else {\n            console.warn(`[EventBus] No subscribers for topic \"${topic}\". Broadcast ignored.`);\n        }\n    }\n    /**\n     * Publishes data to a specific topic, targeting ONLY a component with the given ID.\n     * @param targetComponentId The ID of the component that should receive the message.\n     * @param topic The name of the event topic.\n     * @param data The data to be passed to the target component's subscriber.\n     */\n    publishTo(targetComponentId, topic, data) {\n        const topicSubscribers = this.subscribers.get(topic);\n        if (topicSubscribers) {\n            console.log(`[EventBus] Publishing (targeted) to topic: \"${topic}\" for component: \"${targetComponentId}\"`, data);\n            // Filter subscribers to find only those matching the targetComponentId\n            const targetSubscribers = topicSubscribers.filter(sub => sub.id === targetComponentId);\n            if (targetSubscribers.length === 0) {\n                console.warn(`[EventBus] No subscriber found for topic \"${topic}\" with target ID \"${targetComponentId}\". Targeted publish ignored.`);\n            }\n            // Execute callbacks for the targeted subscribers\n            [...targetSubscribers].forEach(sub => {\n                try {\n                    sub.callback(data);\n                }\n                catch (e) {\n                    console.error(`[EventBus] Error in targeted subscriber for topic \"${topic}\" (ID: ${sub.id}):`, e);\n                }\n            });\n        }\n        else {\n            console.warn(`[EventBus] Topic \"${topic}\" has no subscribers at all. Targeted publish ignored.`);\n        }\n    }\n}\nconst eventBus = EventBus.getInstance();\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Application/EventBus.js?");

/***/ }),

/***/ "./dist/UI/Application/GlobalStateStore.js":
/*!*************************************************!*\
  !*** ./dist/UI/Application/GlobalStateStore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalStateStore: () => (/* binding */ GlobalStateStore)\n/* harmony export */ });\n/* harmony import */ var _helpers_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/all */ \"./dist/helpers/all.js\");\n/* harmony import */ var _ApplicationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ApplicationManager */ \"./dist/UI/Application/ApplicationManager.js\");\n\n\nclass GlobalStateStore {\n    _state;\n    observedState;\n    constructor(initialState) {\n        this._state = initialState;\n        // Make the entire global state object observable\n        this.observedState = _helpers_all__WEBPACK_IMPORTED_MODULE_0__[\"default\"].observeAll(this._state, this.handleStateChange.bind(this));\n    }\n    handleStateChange() {\n        console.log(\"Global State Changed:\", this._state);\n        _ApplicationManager__WEBPACK_IMPORTED_MODULE_1__.eventBus.publish('globalStateChanged', this._state);\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Application/GlobalStateStore.js?");

/***/ }),

/***/ "./dist/UI/Components/Core/PageComponent.js":
/*!**************************************************!*\
  !*** ./dist/UI/Components/Core/PageComponent.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PageComponent: () => (/* binding */ PageComponent)\n/* harmony export */ });\n/* harmony import */ var _UIComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UIComponent */ \"./dist/UI/UIComponent.js\");\n\n/**\n * Abstract base class for all application page components.\n * Provides common lifecycle methods and ensures correct property typing for pages.\n *\n * @template TState The specific state type for this page. Must extend IPageState.\n */\nclass PageComponent\n// Tell UIComponentBase that its properties will be IPageComponentProperties<TState>\n extends _UIComponent__WEBPACK_IMPORTED_MODULE_0__.UIComponentBase // <--- CRUCIAL CHANGE HERE!\n {\n    // No need to redeclare 'properties' here; it's correctly inherited from UIComponentBase\n    // as IPageComponentProperties<TState> due to the extends clause above.\n    /**\n     * Initializes a new instance of the PageComponent.\n     *\n     * @param properties The properties bag for this page component, including router details.\n     */\n    constructor(properties) {\n        super(properties); // Pass the page-specific properties directly to the base UIComponentBase constructor.\n        // You can now safely access `this.properties.path`, `this.properties.router`, etc.\n        // No optional chaining `?.` or non-null assertions `!` are needed for these\n        // because IPageComponentProperties guarantees their presence.\n        // You might keep these checks as defensive runtime assertions if external code\n        // could bypass TypeScript:\n        if (!this.properties.path) {\n            console.warn(`[${this.properties.id}] PageComponent initialized without a 'path' property.`);\n        }\n        if (!this.properties.router) {\n            console.error(`[${this.properties.id}] PageComponent initialized without a 'router' instance.`);\n        }\n    }\n    // ... (rest of PageComponent methods remain the same)\n    async onEnter(prevProps) {\n        console.log(`[${this.properties.id}] Page entered. Path: ${this.properties.path}`);\n        // ...\n    }\n    onLeave() {\n        console.log(`[${this.properties.id}] Page left.`);\n        this.dispose();\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Components/Core/PageComponent.js?");

/***/ }),

/***/ "./dist/UI/Components/Core/RootUIComponent.js":
/*!****************************************************!*\
  !*** ./dist/UI/Components/Core/RootUIComponent.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RootUIComponent: () => (/* binding */ RootUIComponent)\n/* harmony export */ });\n/* harmony import */ var _UIComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UIComponent */ \"./dist/UI/UIComponent.js\");\n/* harmony import */ var _RouterOutletComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RouterOutletComponent */ \"./dist/UI/Components/Core/RouterOutletComponent.js\");\n\n\nconst RootUIComponentTemplate = (component) => /*html*/ `\r\n    <div class=\"app-container min-h-screen flex flex-col\">\r\n        <header class=\"bg-gray-800 text-white p-4 shadow-md\">\r\n            <nav class=\"container mx-auto flex justify-between items-center\">\r\n                <a href=\"#/\" class=\"text-2xl font-bold hover:text-blue-300 transition-colors\">My App</a>\r\n                <div class=\"space-x-4\">\r\n                    <a href=\"#/\" class=\"hover:text-blue-300 transition-colors\">Home</a>\r\n                    <a href=\"#/products/1\" class=\"hover:text-blue-300 transition-colors\">Products</a>\r\n                    <a href=\"#/about\" class=\"hover:text-blue-300 transition-colors\">About</a>\r\n                </div>\r\n            </nav>\r\n        </header>\r\n        \r\n        <main id=\"main-content\" class=\"flex-grow container mx-auto p-4\">\r\n            </main>\r\n\r\n        <footer class=\"bg-gray-800 text-white p-4 text-center mt-auto\">\r\n            &copy; ${new Date().getFullYear()} My Awesome App. All rights reserved.\r\n        </footer>\r\n    </div>\r\n`;\nclass RootUIComponent extends _UIComponent__WEBPACK_IMPORTED_MODULE_0__.UIComponentBase {\n    constructor(properties) {\n        super({\n            ...properties,\n            // Assign the template function to the 'template' property\n            template: RootUIComponentTemplate\n        });\n        // Instantiate RouterOutletComponent and add it to child components.\n        // The ID ('main-router-outlet') must match the outletSelector used by your Router.\n        this.childComponents.push(new _RouterOutletComponent__WEBPACK_IMPORTED_MODULE_1__.RouterOutletComponent({ id: 'main-router-outlet', outletId: 'main-content' }));\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Components/Core/RootUIComponent.js?");

/***/ }),

/***/ "./dist/UI/Components/Core/RouterOutletComponent.js":
/*!**********************************************************!*\
  !*** ./dist/UI/Components/Core/RouterOutletComponent.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterOutletComponent: () => (/* binding */ RouterOutletComponent)\n/* harmony export */ });\n/* harmony import */ var _UIComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../UIComponent */ \"./dist/UI/UIComponent.js\");\n// src/Components/RouterOutletComponent.ts\n\nclass RouterOutletComponent extends _UIComponent__WEBPACK_IMPORTED_MODULE_0__.UIComponentBase {\n    // Optionally, store the active page component internally\n    _activePageComponent = null;\n    _outletElement = null; // Reference to the actual div for the outlet\n    constructor(properties) {\n        super(properties);\n        if (!this.properties.outletId) {\n            throw new Error(\"RouterOutletComponent requires an 'outletId' property.\");\n        }\n    }\n    async render() {\n        return new Promise(resolve => {\n            const html = /*html*/ `\r\n                <div id=\"${this.properties.outletId}\" class=\"router-outlet\">\r\n                </div>\r\n            `;\n            const element = this.toHTMLElement(html);\n            this._applyCommonElementProperties(element);\n            this._outletElement = element; // Store reference to the rendered outlet div\n            resolve({ result: element });\n        });\n    }\n    /**\n     * Loads and displays a new page component in the router outlet.\n     * This method assumes `newPageComponent` is an instance of `PageComponent` (or something that implements `IPageComponent`).\n     *\n     * @param newPageComponent The new page component instance to load.\n     * @param prevPageComponent The previous page component instance (optional, for onLeave/onEnter logic).\n     */\n    async loadPageComponent(newPageComponent, // <--- THIS IS THE CRUCIAL CHANGE!\n    prevPageComponent) {\n        // --- Existing component cleanup ---\n        if (this._activePageComponent) {\n            if (this._activePageComponent.onLeave) {\n                this._activePageComponent.onLeave();\n            }\n            this._activePageComponent.dispose();\n            if (this._outletElement) {\n                this._outletElement.innerHTML = ''; // Clear previous content\n            }\n        }\n        this._activePageComponent = newPageComponent;\n        // --- Render and append new component ---\n        if (this._outletElement) {\n            try {\n                const renderResult = await newPageComponent.render();\n                if (renderResult.result) {\n                    this._outletElement.appendChild(renderResult.result);\n                }\n            }\n            catch (error) {\n                console.error(`Error rendering new page component ${newPageComponent.properties.id}:`, error);\n                return;\n            }\n        }\n        else {\n            console.error(`RouterOutletComponent: Outlet element with ID \"${this.properties.outletId}\" not found for rendering.`);\n            return;\n        }\n        // --- Call onEnter on the new component ---\n        if (newPageComponent.onEnter) {\n            // NOW, `newPageComponent.properties` is correctly typed as `IPageComponentProperties<IPageState>`\n            // which guarantees the 'router' property exists.\n            const router = newPageComponent.properties.router; // <--- THIS LINE WILL NOW BE VALID!\n            console.log(`RouterOutlet: Navigating to page ${newPageComponent.properties.path}. Router instance:`, router);\n            await newPageComponent.onEnter(prevPageComponent?.properties);\n        }\n        else {\n            console.warn(`PageComponent ${newPageComponent.properties.id} does not have an onEnter method.`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Components/Core/RouterOutletComponent.js?");

/***/ }),

/***/ "./dist/UI/Router/Router.js":
/*!**********************************!*\
  !*** ./dist/UI/Router/Router.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Router: () => (/* binding */ Router)\n/* harmony export */ });\n// Core/Router.ts\nclass Router {\n    outletSelector;\n    routes;\n    outletElement = null;\n    currentComponent = null; // Track current page component\n    isStarted = false; // Flag to ensure router only starts once\n    constructor(routes, outletSelector) {\n        this.outletSelector = outletSelector;\n        this.routes = routes;\n    }\n    start() {\n        if (this.isStarted) {\n            console.warn(\"Router has already been started.\");\n            return;\n        }\n        this.outletElement = document.querySelector(this.outletSelector);\n        if (!this.outletElement) {\n            console.error(`Router outlet element not found: ${this.outletSelector}`);\n            return;\n        }\n        // Listen for hash changes\n        window.addEventListener('hashchange', this.handleHashChange.bind(this));\n        // Handle the initial route load\n        this.handleHashChange();\n        this.isStarted = true;\n        console.log(\"Router started successfully.\");\n    }\n    stop() {\n        if (!this.isStarted) {\n            console.warn(\"Router is not running, cannot stop.\");\n            return;\n        }\n        window.removeEventListener('hashchange', this.handleHashChange.bind(this));\n        // Dispose current component if it exists\n        if (this.currentComponent) {\n            this.currentComponent.dispose();\n            this.currentComponent = null;\n        }\n        this.outletElement = null;\n        this.isStarted = false;\n        console.log(\"Router stopped.\");\n    }\n    // NEW: Method to navigate to a specific path\n    navigate(path) {\n        // Ensure the path starts with '#' for hash routing\n        const targetPath = path.startsWith('#') ? path : `#${path}`;\n        if (window.location.hash !== targetPath) {\n            window.location.hash = targetPath; // This will trigger 'hashchange' event\n        }\n        else {\n            // If the hash is the same, manually trigger route handling\n            // This is important for navigating to the same route with different params (e.g., /products/1 -> /products/2)\n            this.handleHashChange();\n        }\n    }\n    // NEW: Method to navigate back in browser history\n    goBack() {\n        console.log('Router: Navigating back in history.');\n        window.history.back();\n    }\n    async handleHashChange() {\n        const path = window.location.hash.slice(1) || '/';\n        console.log(`Router: Handling hash change to: ${path}`);\n        let matchedRoute;\n        let routeParams = {};\n        // Find a matching route and extract parameters\n        for (const route of this.routes) {\n            const routeRegex = new RegExp(`^${route.path.replace(/:([a-zA-Z0-9_]+)/g, '([a-zA-Z0-9_\\\\-]+)')}$`);\n            const match = path.match(routeRegex);\n            if (match) {\n                matchedRoute = route;\n                const paramNames = (route.path.match(/:([a-zA-Z0-9_]+)/g) || []).map(p => p.slice(1));\n                paramNames.forEach((name, index) => {\n                    routeParams[name] = match[index + 1];\n                });\n                break;\n            }\n        }\n        if (matchedRoute && this.outletElement) {\n            if (this.currentComponent) {\n                this.currentComponent.onLeave();\n                this.currentComponent.dispose();\n                this.currentComponent = null;\n            }\n            const ComponentClass = matchedRoute.component;\n            const propsFromRoute = matchedRoute.defaultProps || {};\n            const { id = 'generated-id-' + Math.random().toString(36).substring(2, 10), ...restDefaultProps } = propsFromRoute;\n            const componentProps = {\n                ...restDefaultProps, // Includes all other properties from defaultProps\n                id: id, // Assign the now guaranteed string 'id'\n                path: matchedRoute.path,\n                router: this,\n                routeParams: routeParams\n            };\n            this.currentComponent = new ComponentClass(componentProps);\n            try {\n                const renderResult = await this.currentComponent.render();\n                if (renderResult.result) {\n                    this.outletElement.innerHTML = '';\n                    this.outletElement.appendChild(renderResult.result);\n                    console.log(`Router: Rendered component for path \"${path}\"`);\n                    await this.currentComponent.onEnter();\n                }\n                else {\n                    console.error(`Router: Render result for path \"${path}\" was empty.`);\n                }\n            }\n            catch (error) {\n                console.error(`Router: Error rendering component for path \"${path}\":`, error);\n                this.navigate('/error');\n            }\n        }\n        else if (this.outletElement) {\n            console.warn(`Router: No route found for path: ${path}. Showing 404.`);\n            if (this.currentComponent) {\n                this.currentComponent.onLeave();\n                this.currentComponent.dispose();\n                this.currentComponent = null;\n            }\n            this.outletElement.innerHTML = `<div class=\"p-6 text-center text-red-500\">\r\n                                                <h1 class=\"text-4xl font-bold mb-4\">404 - Not Found</h1>\r\n                                                <p>The page <code>${path}</code> you are looking for does not exist.</p>\r\n                                                <button class=\"mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded\" onclick=\"window.location.hash = '/'\">Go to Home</button>\r\n                                            </div>`;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/Router/Router.js?");

/***/ }),

/***/ "./dist/UI/UIComponent.js":
/*!********************************!*\
  !*** ./dist/UI/UIComponent.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIComponentBase: () => (/* binding */ UIComponentBase)\n/* harmony export */ });\n/* harmony import */ var _helpers_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/all */ \"./dist/helpers/all.js\");\n/* harmony import */ var _Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Application/ApplicationManager */ \"./dist/UI/Application/ApplicationManager.js\");\n\n\nclass UIComponentBase {\n    childComponents;\n    _activeSubscriptions;\n    _activeEventListeners;\n    uuid; // Made required as it's always assigned\n    _element = null;\n    // The 'properties' member is now correctly typed and always present after the constructor.\n    properties;\n    _parent;\n    constructor(properties) {\n        this.properties = properties;\n        // Ensure state is initialized, still using TState for the state part\n        if (!this.properties.state) {\n            this.properties.state = {};\n        }\n        this.childComponents = [];\n        this._activeEventListeners = [];\n        this._activeSubscriptions = [];\n        this.uuid = properties.id || crypto.randomUUID();\n        this._parent = undefined;\n        this.subscribe('globalStateChanged', this.handleGlobalStateChange.bind(this));\n    }\n    /**\n     * Handles updates to the global application state.\n     *\n     * @param newData - The updated global application state.\n     */\n    handleGlobalStateChange(newData) {\n        console.log(`[${this.properties?.id}] Global state updated:`, newData);\n    }\n    async handleStateChange() {\n    }\n    /**\n     * Adds a child UIComponent to this component's list of child components.\n     *\n     * @param component - The UIComponent instance to add as a child.\n     */\n    addChild(component) {\n        this.childComponents.push(component);\n        if (component instanceof UIComponentBase) {\n            component._parent = this;\n        }\n    }\n    addChilds(components) {\n        return components.forEach(component => {\n            this.addChild(component);\n        });\n    }\n    /**\n       * Subscribes the component to a specific event topic on the global EventBus.\n       * The component's ID is automatically passed for targeted messaging.\n       * @param topic The name of the event topic.\n       * @param action The callback function to execute when the event is published.\n       */\n    subscribe(topic, action) {\n        if (!this.properties?.id) {\n            console.warn(`[${this.constructor.name}] Cannot subscribe to topic \"${topic}\" without an ID. Subscription ignored.`);\n            return;\n        }\n        const boundAction = action.bind(this);\n        _Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_1__.eventBus.subscribe(topic, boundAction, this.properties.id);\n        this._activeSubscriptions.push({ topic, action: boundAction });\n    }\n    /**\n     * Publishes data to a specific event topic on the global EventBus for all subscribers.\n     * @param topic The name of the event topic.\n     * @param data The data to be passed to the subscribers.\n     */\n    publish(topic, data) {\n        _Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_1__.eventBus.publish(topic, data);\n    }\n    /**\n   * Publishes data to a specific event topic, targeting ONLY a component with the given ID.\n   * @param targetComponentId The ID of the component that should receive the message.\n   * @param topic The name of the event topic.\n   * @param data The data to be passed to the target component's subscriber.\n   */\n    publishTo(targetComponentId, topic, data) {\n        _Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_1__.eventBus.publishTo(targetComponentId, topic, data);\n    }\n    /**\n     * Converts an HTML fragment string into a DOM element.\n     *\n     * @param html - The HTML to convert.\n     * @returns The resulting DOM element.\n     */\n    toHTMLElement(html) {\n        return _helpers_all__WEBPACK_IMPORTED_MODULE_0__.$D.toDOM(html);\n    }\n    /**\n         * Performs a querySelector on the component's own root DOM element.\n         * This allows querying for elements *within* the component's specific rendered output.\n         * The component must be rendered and attached to the DOM for this to find elements.\n         * @param selector The CSS selector string.\n         * @returns The first matching HTMLElement within the component's root, or null.\n         */\n    querySelector(selector) {\n        if (!this.properties?.id) {\n            console.warn(`[${this.constructor.name}] querySelector: Cannot query without a component ID. Selector: \"${selector}\"`);\n            return null;\n        }\n        // Get the component's *own root element* using its ID.\n        // This is the element that contains all the HTML rendered by *this* component.\n        const componentRootElement = _helpers_all__WEBPACK_IMPORTED_MODULE_0__.$D.get(`#${this.properties.id}`);\n        if (componentRootElement) {\n            // Perform the query *within* the component's own root element\n            return _helpers_all__WEBPACK_IMPORTED_MODULE_0__.$D.get(selector, componentRootElement);\n        }\n        console.warn(`[${this.constructor.name}] querySelector: Component root element (ID: \"${this.properties.id}\") not found in DOM. Cannot query. Selector: \"${selector}\"`);\n        return null;\n    }\n    /**\n     * Performs a querySelectorAll on the component's own root DOM element.\n     * This allows querying for elements *within* the component's specific rendered output.\n     * The component must be rendered and attached to the DOM for this to find elements.\n     * @param selector The CSS selector string.\n     * @returns An array of matching HTMLElements within the component's root, or an empty array.\n     */\n    querySelectorAll(selector) {\n        if (!this.properties?.id) {\n            console.warn(`[${this.constructor.name}] querySelectorAll: Cannot query without a component ID. Selector: \"${selector}\"`);\n            return [];\n        }\n        const componentRootElement = _helpers_all__WEBPACK_IMPORTED_MODULE_0__.$D.get(`#${this.properties.id}`);\n        if (componentRootElement) {\n            return _helpers_all__WEBPACK_IMPORTED_MODULE_0__.$D.getAll(selector, componentRootElement);\n        }\n        console.warn(`[${this.constructor.name}] querySelectorAll: Component root element (ID: \"${this.properties.id}\") not found in DOM. Cannot query. Selector: \"${selector}\"`);\n        return [];\n    }\n    // --- Core Render Method (Default Implementation) ---\n    // This is no longer abstract. Subclasses can override it.\n    async render() {\n        const html = this.getTemplateHtml();\n        if (html === null) {\n            // If no template is provided, return an empty result or throw an error\n            // depending on desired behavior for components without templates.\n            console.warn(`[${this.properties.id}] Component has no template and no custom render method.`);\n            return { result: document.createElement('div') }; // Return an empty div\n        }\n        const element = this.toHTMLElement(html); // Assume single root for _applyCommonElementProperties\n        this._applyCommonElementProperties(element);\n        this._element = element; // Store reference to the root element\n        return { result: element };\n    }\n    /**\n     * Traverses the component's child hierarchy (depth-first) and executes a callback for each component.\n     *\n     * @param callback - The function to execute for each component.\n     * If the callback returns `false`, the traversal will stop.\n     * @returns `true` if the traversal completed, `false` if it was stopped by the callback.\n     */\n    traverse(callback) {\n        // Process current component (optional, depending on if you want to include self in traversal)\n        // For typical child traversal, we start with children.\n        for (const child of this.childComponents) {\n            if (callback(child) === false) {\n                return false; // Stop traversal if callback returns false\n            }\n            // Recursively traverse children's children\n            if (child instanceof UIComponentBase && !child.traverse(callback)) {\n                return false; // Propagate stop signal from deeper traversal\n            }\n        }\n        return true; // Traversal completed\n    }\n    /**\n     * Finds the first descendant UIComponent that satisfies the given predicate.\n     * Performs a depth-first search.\n     *\n     * @param predicate - A function that returns `true` if the component is the one being searched for.\n     * @returns The first `UIComponent` that satisfies the predicate, or `undefined` if not found.\n     */\n    find(predicate) {\n        let foundComponent = undefined;\n        this.traverse((component) => {\n            if (predicate(component)) {\n                foundComponent = component;\n                return false; // Stop traversal once found\n            }\n            return true; // Continue traversal\n        });\n        return foundComponent;\n    }\n    /**\n     * Finds a child component by its ID.\n     *\n     * @param id The ID of the component to find.\n     * @returns The component with the matching ID, or `undefined` if not found.\n     */\n    findById(id) {\n        return this.find(component => component.properties?.id === id);\n    }\n    /**\n         * Helper method to append a child's rendered DOM to the correct location within the parent's DOM.\n         * It uses the child's properties.targetSelector if provided, otherwise appends to the parent's root element.\n         * This method is intended to be called by parent components within their own render method.\n         *\n         * @param parentRenderedElement The DOM element or DocumentFragment representing the parent component's own rendered output.\n         * @param childComponent The child UIComponent instance whose rendered output is being appended.\n         * @param childRenderedElement The DOM element or DocumentFragment representing the child component's rendered output.\n         */\n    _appendChildToParentDom(parentRenderedElement, childComponent, childRenderedElement) {\n        const targetSelector = childComponent.properties?.targetSelector;\n        let appendTarget = parentRenderedElement; // Default target is parent's root\n        // If a targetSelector is provided AND the parent's element is an HTMLElement (DocumentFragment doesn't have querySelector)\n        if (targetSelector && parentRenderedElement instanceof HTMLElement) {\n            const foundTarget = parentRenderedElement.querySelector(targetSelector);\n            if (foundTarget instanceof HTMLElement) {\n                appendTarget = foundTarget; // Found the specific target element\n            }\n            else {\n                console.warn(`[${this.properties?.id || 'Unnamed Parent'}] Target selector \"${targetSelector}\" ` +\n                    `for child \"${childComponent.properties?.id || 'Unnamed Child'}\" not found within parent's rendered DOM. ` +\n                    `Appending to parent's root element (ID: ${parentRenderedElement.id || 'N/A'}) instead.`);\n            }\n        }\n        else if (targetSelector && !(parentRenderedElement instanceof HTMLElement)) {\n            console.warn(`[${this.properties?.id || 'Unnamed Parent'}] Target selector \"${targetSelector}\" ` +\n                `for child \"${childComponent.properties?.id || 'Unnamed Child'}\" was provided, but parent's rendered element is a DocumentFragment. ` +\n                `Selectors cannot be used directly on DocumentFragments. Appending to DocumentFragment directly.`);\n        }\n        appendTarget.appendChild(childRenderedElement);\n    }\n    /**\n     * Renders all direct child components and appends their results to the specified parent DOM element.\n     * This method is intended to be called by concrete component's render methods.\n     *\n     * @param parentRenderedElement The DOM element or DocumentFragment representing the parent component's own rendered output.\n     * Children will be appended within this element based on their targetSelector.\n     */\n    async _renderAndAppendChildren(parentRenderedElement) {\n        // 1. Gather all child render promises\n        const childRenderPromises = this.childComponents\n            .filter(child => child.render) // Only process children that have a render method\n            .map(child => child.render()); // Call render and get the promise for each child\n        // 2. Wait for all children to render concurrently\n        const childRenderResults = await Promise.all(childRenderPromises);\n        // 3. Iterate over the results and append each child's rendered DOM\n        childRenderResults.forEach((childResult, index) => {\n            const childComponent = this.childComponents[index]; // Get the original child component instance\n            if (childResult?.result) {\n                // Use the helper to append to the correct slot within the parent's DOM\n                this._appendChildToParentDom(parentRenderedElement, childComponent, childResult.result);\n            }\n        });\n    }\n    /**\n    * Helper to safely add an event listener and track it for disposal.\n    * @param element The DOM element to attach the listener to.\n    * @param eventName The name of the event (e.g., 'click', 'change').\n    * @param handler The event handler function.\n    */\n    _addTrackedEventListener(element, eventName, handler) {\n        element.addEventListener(eventName, handler);\n        this._activeEventListeners.push({ element, eventName, handler });\n    }\n    /**\n    * Applies common properties (data attributes, event handlers) to a component's root DOM element.\n    * This method is intended to be called by concrete component's render methods.\n    *\n    * @param element The HTMLElement that is the root of the component's own rendered output.\n    */\n    _applyCommonElementProperties(element) {\n        if (this.properties?.state) {\n            for (const key in this.properties.state) {\n                if (Object.prototype.hasOwnProperty.call(this.properties.state, key)) {\n                    element.setAttribute(`data-${key}`, String(this.properties.state[key]));\n                }\n            }\n        }\n        if (this.properties?.eventHandlers) {\n            for (const eventName in this.properties.eventHandlers) {\n                if (Object.prototype.hasOwnProperty.call(this.properties.eventHandlers, eventName)) {\n                    const handler = this.properties.eventHandlers[eventName];\n                    this._addTrackedEventListener(element, eventName, handler);\n                }\n            }\n        }\n    }\n    dispose() {\n        console.log(`Disposing component: ${this.properties?.id || 'Unnamed'}`);\n        // Unsubscribe all EventBus subscriptions made by this component\n        this._activeSubscriptions.forEach(sub => {\n            if (this.properties?.id) {\n                _Application_ApplicationManager__WEBPACK_IMPORTED_MODULE_1__.eventBus.unsubscribe(sub.topic, sub.action, this.properties.id); // Pass component's ID for unsubscribe!\n            }\n            else {\n                console.warn(`[${this.constructor.name}] Cannot unsubscribe from topic \"${sub.topic}\" without an ID.`);\n            }\n        });\n        this._activeSubscriptions = [];\n        // Remove all DOM event listeners attached by this component\n        this._activeEventListeners.forEach(listener => {\n            listener.element.removeEventListener(listener.eventName, listener.handler);\n        });\n        this._activeEventListeners = [];\n        // Recursively dispose of child components\n        this.childComponents.forEach(child => {\n            if (child instanceof UIComponentBase) { // Ensure it's a UIComponentBase instance to call its dispose\n                child.dispose();\n            }\n        });\n    }\n    /**\n   * Retrieves the direct logical parent UIComponent of this component.\n   * This method allows a child component to access its parent in the component hierarchy.\n   * @returns The parent UIComponent, or `undefined` if this is a root component.\n   */\n    parent() {\n        return this._parent; // Cast to the expected parent type for convenience\n    }\n    /**\n     * Retrieves the HTML template for the component.\n     *\n     * If the `template` property exists in `this.properties` and is a function,\n     * it invokes the function with the current instance and returns the resulting HTML string.\n     * If the `template` property exists but is not a function, a warning is logged and `null` is returned.\n     * If the `template` property does not exist, `null` is returned.\n     *\n     * @returns {string | null} The HTML template string, or `null` if not available or invalid.\n     */\n    getTemplateHtml() {\n        if (this.properties?.template) {\n            if (typeof this.properties.template === 'function') {\n                return this.properties.template(this);\n            }\n            else {\n                console.warn(`[${this.properties.id || this.constructor.name}] Template property is not a function, found:`, typeof this.properties.template);\n                return null;\n            }\n        }\n        return null;\n    }\n    // NEW: Method to handle re-rendering the component\n    async reRender() {\n        // Only attempt to re-render if the component has been initially rendered\n        // and is currently attached to the DOM.\n        if (this._element && this._element.parentNode) {\n            const oldElement = this._element; // Store reference to the current DOM element\n            const parent = oldElement.parentNode; // Store reference to its parent\n            try {\n                // Call the main render logic which will generate new HTML based on current state/properties\n                const renderResult = await this.render();\n                const newElement = renderResult.result;\n                if (newElement && parent) {\n                    // Replace the old DOM element with the newly rendered one\n                    parent.replaceChild(newElement, oldElement);\n                    if (newElement instanceof HTMLElement) {\n                        this._element = newElement; // Update the internal reference to the new DOM element\n                    }\n                    else {\n                        this._element = null;\n                        console.warn(`[${this.properties?.id || this.constructor.name}] New element is not an HTMLElement. Internal _element set to null.`);\n                    }\n                    console.log(`[${this.properties?.id || this.constructor.name}] Component re-rendered and DOM updated.`);\n                }\n                else if (!newElement) {\n                    console.warn(`[${this.properties?.id || this.constructor.name}] Re-render failed: New element was not generated.`);\n                }\n                else { // parent is null, meaning oldElement was detached before re-render could replace it\n                    console.warn(`[${this.properties?.id || this.constructor.name}] Re-render aborted: Old element was detached from DOM.`);\n                }\n            }\n            catch (error) {\n                console.error(`[${this.properties?.id || this.constructor.name}] Error during re-render:`, error);\n            }\n        }\n        else if (this._element) {\n            // If _element exists but has no parent, it means it's not in the DOM.\n            // Re-rendering in this case just updates _element internally, but won't show on screen.\n            console.warn(`[${this.properties.id || this.constructor.name}] Re-render called but component is not currently in the DOM. Updating internal element only.`);\n            await this.render(); // Still call render to update the internal _element state\n        }\n        else {\n            console.warn(`[${this.properties.id || this.constructor.name}] Re-render called before initial render or after dispose. No action taken.`);\n        }\n    }\n    updateState(newState) {\n        // Merge the new state with the existing state\n        // Using 'as TState' to assert the final type after merging\n        this.properties.state = { ...this.properties.state, ...newState };\n        console.log(`[${this.properties.id || this.constructor.name}] State updated:`, this.properties.state);\n        // Trigger a re-render of the component to reflect the state changes\n        this.reRender();\n    }\n}\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/UI/UIComponent.js?");

/***/ }),

/***/ "./dist/helpers/all.js":
/*!*****************************!*\
  !*** ./dist/helpers/all.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $D: () => (/* binding */ $D),\n/* harmony export */   DathorHelpers: () => (/* binding */ DathorHelpers),\n/* harmony export */   TaskScheduler: () => (/* binding */ TaskScheduler),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass TaskScheduler {\n    tasks = [];\n    animationFrameId = null;\n    startTime = null;\n    nextTaskId = 0;\n    isPaused = false;\n    pauseStartTime = null;\n    idleTime = 0;\n    /**\n     * Adds a new task to the task list with a specified delay.\n     *\n     * @param callback - The function to be executed when the task is triggered.\n     * @param delay - The delay in milliseconds after which the task should be executed.\n     * @returns The unique identifier for the added task.\n     */\n    addTask(callback, delay) {\n        const taskId = this.nextTaskId++;\n        this.tasks.push({ id: taskId, time: delay + this.idleTime, callback });\n        this.tasks.sort((a, b) => a.time - b.time);\n        this.start();\n        return taskId;\n    }\n    /**\n     * Removes a task from the task list by its ID.\n     * If the task is found and removed, it checks if the task list is empty and stops the process if it is.\n     *\n     * @param {number} taskId - The ID of the task to be removed.\n     * @returns {boolean} - Returns true if the task was found and removed, otherwise returns false.\n     */\n    removeTask(taskId) {\n        const index = this.tasks.findIndex(task => task.id === taskId);\n        if (index !== -1) {\n            this.tasks.splice(index, 1);\n            if (this.tasks.length === 0) {\n                this.stop();\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Reschedules a task by updating its delay time and re-sorting the task list.\n     *\n     * @param taskId - The ID of the task to be rescheduled.\n     * @param newDelay - The new delay time to be set for the task.\n     * @returns A boolean indicating whether the task was successfully rescheduled.\n     */\n    rescheduleTask(taskId, newDelay) {\n        const task = this.tasks.find(task => task.id === taskId);\n        if (task) {\n            task.time = newDelay + this.idleTime;\n            this.tasks.sort((a, b) => a.time - b.time);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Starts the task scheduler. If the scheduler is paused, it will resume from where it left off.\n     * It calculates the idle time during the pause and adjusts the task times accordingly.\n     * The tasks are executed in order based on their scheduled time.\n     * If there are no tasks left, the scheduler stops automatically.\n     *\n     * @remarks\n     * - If the scheduler is already running, this method does nothing.\n     * - The tasks are sorted by their scheduled time before execution.\n     *\n     * @returns {void}\n     */\n    start() {\n        if (this.animationFrameId !== null)\n            return;\n        if (this.isPaused && this.pauseStartTime) {\n            this.idleTime += performance.now() - this.pauseStartTime;\n            this.pauseStartTime = null;\n            this.isPaused = false;\n            this.tasks.forEach(task => task.time += this.idleTime);\n            this.tasks.sort((a, b) => a.time - b.time);\n        }\n        this.startTime = performance.now();\n        const executeTasks = (currentTime) => {\n            if (this.startTime === null)\n                return;\n            const elapsed = currentTime - this.startTime;\n            while (this.tasks.length > 0 && this.tasks[0].time <= elapsed) {\n                const task = this.tasks.shift();\n                if (task) {\n                    task.callback();\n                }\n            }\n            if (this.tasks.length > 0) {\n                this.animationFrameId = requestAnimationFrame(executeTasks);\n            }\n            else {\n                this.stop();\n            }\n        };\n        this.animationFrameId = requestAnimationFrame(executeTasks);\n    }\n    /**\n     * Stops the animation by canceling the current animation frame request.\n     * If an animation frame is currently active, it will be canceled and the\n     * animation frame ID and start time will be reset to null.\n     */\n    stop() {\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n            this.startTime = null;\n        }\n    }\n    /**\n     * Clears the current tasks, stops any ongoing processes, and resets the idle time to zero.\n     */\n    clear() {\n        this.tasks = [];\n        this.stop();\n        this.idleTime = 0;\n    }\n    /**\n     * Pauses the animation if it is currently running.\n     *\n     * This method cancels the current animation frame request and sets the\n     * `animationFrameId` to `null`. It also records the time at which the\n     * pause occurred and sets the `isPaused` flag to `true`.\n     *\n     * @remarks\n     * This method has no effect if the animation is already paused or if\n     * there is no animation frame request pending.\n     */\n    pause() {\n        if (this.animationFrameId !== null && !this.isPaused) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n            this.pauseStartTime = performance.now();\n            this.isPaused = true;\n        }\n    }\n}\nclass DathorHelpers {\n    /**\n     * Sets or gets the value of an HTML input element selected by the given selector.\n     *\n     * @template T - The type of the value to be returned.\n     * @param {string} selector - The CSS selector to find the HTML input element.\n     * @param {any} [value] - The value to set for the input element. If not provided, the current value of the input element will be returned.\n     * @returns {T | null} - The value of the input element cast to type T, or null if the element is not found.\n     */\n    static value(selector, value) {\n        const element = DathorHelpers.get(selector);\n        if (value && element)\n            element.value = value;\n        return element ? element.value : null;\n    }\n    /**\n     * Creates and returns a new instance of `TaskScheduler`.\n     *\n     * @returns {TaskScheduler} A new `TaskScheduler` instance.\n     */\n    static createTaskScheduler() {\n        return new TaskScheduler();\n    }\n    /**\n     * Retrieves an element from the DOM based on the provided selector.\n     *\n     * @template T - The type of the HTMLElement to be returned.\n     * @param {string} selector - The CSS selector to match the desired element.\n     * @param {Element | DocumentFragment | null} [parent] - The parent element or document fragment to search within. If not provided, the document is used as the parent.\n     * @returns {T | null} - The matched element of type T, or null if no element is found.\n     */\n    static get(selector, parent) {\n        if (!parent) {\n            return document.querySelector(selector); // Handle null parent\n        }\n        return parent.querySelector(selector); // Handle null parent\n    }\n    /**\n   * Filters elements based on a selector within a set of parent elements.\n   *\n   * @param {string} filterSelector - The CSS selector to filter elements.\n   * @param {HTMLElement | HTMLElement[]} parents - The parent element(s) to search within.\n   * @returns {HTMLElement[]} - An array of filtered elements.\n   */\n    static filter(filterSelector, parents) {\n        if (!parents) {\n            return []; // Return empty array if no parents are provided.\n        }\n        if (Array.isArray(parents)) {\n            return parents.flatMap(parent => Array.from(parent.querySelectorAll(filterSelector)));\n        }\n        else {\n            return Array.from(parents.querySelectorAll(filterSelector));\n        }\n    }\n    /**\n     * Retrieves all elements that match the specified CSS selector within the given parent element or document fragment.\n     * If no parent is provided, it searches within the entire document.\n     *\n     * @param selector - The CSS selector to match elements against.\n     * @param parent - Optional. The parent element or document fragment to search within. Defaults to the entire document.\n     * @returns An array of elements that match the specified selector.\n     */\n    static getAll(selector, parent) {\n        const queryResult = parent ? parent.querySelectorAll(selector) : document.querySelectorAll(selector);\n        return Array.from(queryResult);\n    }\n    /**\n     * Replaces an old HTML element with a new HTML element.\n     *\n     * @param oldElement - The existing HTML element to be replaced.\n     * @param newElement - The new HTML element to replace the old element with.\n     */\n    static replace(oldElement, newElement) {\n        oldElement.replaceWith(newElement);\n    }\n    /**\n     * Adds an event listener to multiple elements specified by a selector or a list of elements.\n     *\n     * @template T - The type of the elements, extending HTMLElement.\n     * @param {string} event - The event type to listen for (e.g., 'click', 'mouseover').\n     * @param {string | NodeListOf<T> | T[]} selectorOrElements - A CSS selector string, a NodeList of elements, or an array of elements to attach the event listener to.\n     * @param {(event?: Event, el?: T) => void} fn - The callback function to execute when the event is triggered. Receives the event object and the element as arguments.\n     * @param {AddEventListenerOptions} [options] - Optional. An options object that specifies characteristics about the event listener.\n     * @param {HTMLElement | DocumentFragment | null} [parentEl] - Optional. The parent element or document fragment to query the selector within. Defaults to the document if not provided.\n     * @returns {void}\n     */\n    static onAll(event, selectorOrElements, fn, options, parentEl) {\n        let elements;\n        if (typeof selectorOrElements === \"string\") {\n            elements = parentEl\n                ? parentEl.querySelectorAll(selectorOrElements)\n                : document.querySelectorAll(selectorOrElements);\n        }\n        else {\n            elements = selectorOrElements;\n        }\n        elements.forEach((el) => {\n            el.addEventListener(event, (e) => {\n                fn(e, el);\n            }, options);\n        });\n    }\n    /**\n     * Creates a debounced function that delays invoking the provided function until after the specified delay has elapsed since the last time the debounced function was invoked.\n     *\n     * @param func - The function to debounce.\n     * @param delay - The number of milliseconds to delay.\n     * @returns A new debounced function.\n     */\n    static debounce(func, delay) {\n        let timeoutId;\n        return function (...args) {\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(() => func.apply(this, args), delay);\n        };\n    }\n    /**\n     * Retrieves the FormData object from a given HTML form element.\n     *\n     * @param form - The HTML form element or a string selector to identify the form.\n     * @returns The FormData object containing the form's data, or null if the form element is not found.\n     */\n    static getFormData(form) {\n        const formElement = typeof form === \"string\" ? $D.get(form) : form;\n        if (!formElement)\n            return null;\n        return new FormData(formElement);\n    }\n    /**\n     * Serializes an HTML form into an object, with optional keys to omit or pick.\n     *\n     * @template T - The type of the resulting object.\n     * @template K - The keys of T to omit.\n     * @param {HTMLFormElement} form - The form element to serialize.\n     * @param {K[]} [omit] - An optional array of keys to omit from the resulting object.\n     * @param {(keyof T)[]} [pick] - An optional array of keys to pick from the resulting object.\n     * @returns {Omit<T, K> | Pick<T, keyof Pick<T, keyof T>>} - The serialized form data as an object, with omitted or picked keys.\n     */\n    static serializeForm(form, omit, pick) {\n        const formData = new FormData(form);\n        const serialized = {};\n        formData.forEach((value, key) => {\n            if (serialized[key]) {\n                if (Array.isArray(serialized[key])) {\n                    serialized[key].push(value);\n                }\n                else {\n                    serialized[key] = [serialized[key], value];\n                }\n            }\n            else {\n                serialized[key] = value;\n            }\n        });\n        let result = serialized;\n        if (pick) {\n            result = pick.reduce((acc, key) => {\n                if (result[key]) {\n                    acc[key] = result[key];\n                }\n                return acc;\n            }, {});\n        }\n        if (omit) {\n            result = Object.keys(result).reduce((acc, key) => {\n                if (!omit.includes(key)) {\n                    acc[key] = result[key];\n                }\n                return acc;\n            }, {});\n        }\n        return result;\n    }\n    /**\n     * Creates a throttled version of the provided function that will only execute\n     * the function at most once every specified limit of milliseconds.\n     *\n     * @param func - The function to throttle.\n     * @param limit - The number of milliseconds to wait before allowing the function to be called again.\n     * @returns A throttled version of the provided function.\n     */\n    static throttle(func, limit) {\n        let inThrottle;\n        return function (...args) {\n            if (!inThrottle) {\n                func.apply(this, args);\n                inThrottle = true;\n                setTimeout(() => inThrottle = false, limit);\n            }\n        };\n    }\n    /**\n     * Sets or gets the CSS property value of a given HTML element.\n     *\n     * @param element - The target HTML element or a string selector to identify the element.\n     * @param property - The CSS property name to set or get.\n     * @param value - The value to set for the CSS property. If omitted, the current value of the property will be returned.\n     * @returns The current value of the CSS property if `value` is not provided; otherwise, returns `void`.\n     */\n    static css(element, property, value) {\n        const el = typeof element === \"string\" ? $D.get(element) : element;\n        if (!el)\n            return;\n        if (value === undefined) {\n            return getComputedStyle(el).getPropertyValue(property);\n        }\n        else {\n            el.style.setProperty(property, value);\n        }\n    }\n    /**\n     * Executes an array of tasks, which can be either synchronous functions or functions returning promises,\n     * and returns a promise that resolves when all tasks have completed.\n     *\n     * @param tasks - An array of functions that return either a value or a promise.\n     * @returns A promise that resolves to an array of results when all tasks have completed.\n     *          If any task throws an error or returns a rejected promise, the returned promise will be rejected with that error.\n     */\n    static awaitAll(tasks) {\n        const promises = tasks.map(task => {\n            try {\n                const result = task();\n                if (result instanceof Promise) {\n                    return result; // If it's a promise, return it\n                }\n                else {\n                    return Promise.resolve(result); // If it's sync, wrap it in a promise\n                }\n            }\n            catch (error) {\n                return Promise.reject(error); // Handle errors\n            }\n        });\n        return Promise.all(promises);\n    }\n    /**\n     * Attaches an event listener to elements that match the specified selector, including elements\n     * that are added to the DOM after the initial call. The event listener is reapplied whenever\n     * the DOM changes.\n     *\n     * @template T - The type of the HTMLElement.\n     * @param {string} event - The event type to listen for (e.g., 'click', 'mouseover').\n     * @param {string} selector - The CSS selector to match the elements.\n     * @param {(event?: Event, el?: T) => void} fn - The event handler function to be called when the event is triggered.\n     * @param {AddEventListenerOptions} [options] - Optional options for the event listener (e.g., { capture: true }).\n     * @param {HTMLElement | DocumentFragment | null} [parentEl=document.body] - The parent element to observe for DOM changes. Defaults to document.body.\n     */\n    static live(event, selector, fn, options, parentEl = document.body // Default to document.body\n    ) {\n        const applyListeners = () => {\n            $D.onAll(event, selector, fn, options, parentEl);\n        };\n        applyListeners(); // Apply listeners initially\n        const observer = new MutationObserver((mutationsList) => {\n            for (const mutation of mutationsList) {\n                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n                    applyListeners(); // Reapply listeners on DOM changes\n                    break; // No need to check other mutations if childList changed\n                }\n            }\n        });\n        observer.observe(parentEl instanceof DocumentFragment ? parentEl : parentEl, {\n            childList: true,\n            subtree: true,\n        });\n    }\n    /**\n     * Attaches an event listener to a specified element or elements.\n     *\n     * @template T - The type of the HTMLElement.\n     * @param {string} event - The event type to listen for (e.g., 'click', 'mouseover').\n     * @param {string | HTMLElement | Element | DocumentFragment} selector - The CSS selector string, HTMLElement, Element, or DocumentFragment to attach the event listener to.\n     * @param {(event?: Event, el?: T) => void} fn - The callback function to execute when the event is triggered.\n     * @param {AddEventListenerOptions} [options] - Optional options object that specifies characteristics about the event listener.\n     * @param {HTMLElement | DocumentFragment | null} [parentEl] - Optional parent element to scope the selector query within.\n     * @returns {T | null} - The element to which the event listener was attached, or null if multiple elements were handled or no element was found.\n     */\n    static on(event, selector, fn, options, parentEl) {\n        if (typeof selector === \"string\") {\n            const elements = parentEl\n                ? parentEl.querySelectorAll(selector)\n                : document.querySelectorAll(selector);\n            if (elements.length > 1) {\n                // Delegate to onAll if multiple elements match\n                DathorHelpers.onAll(event, elements, fn, options);\n                return null; // Return null since multiple elements were handled\n            }\n            const target = elements[0];\n            if (target) {\n                target.addEventListener(event, (e) => {\n                    fn(e, target);\n                }, options);\n                return target;\n            }\n            else {\n                return null;\n            }\n        }\n        else if (selector instanceof Element || selector instanceof HTMLElement) {\n            selector.addEventListener(event, (e) => {\n                fn(e, selector);\n            }, options);\n            return selector;\n        }\n        else if (selector instanceof DocumentFragment) {\n            // Handle DocumentFragment: Find the first matching element within.\n            const target = selector.querySelector(selector); // Query inside it\n            if (target) {\n                target.addEventListener(event, (e) => {\n                    fn(e, target);\n                }, options);\n            }\n            return target;\n        }\n        return null;\n    }\n    /**\n     * Removes all child nodes from the specified parent element.\n     *\n     * @param selector - A string representing a CSS selector or an HTMLElement.\n     *                   If a string is provided, the element will be selected using `DOMUtils.get`.\n     *                   If an HTMLElement is provided, it will be used directly.\n     *\n     * @remarks\n     * If the parent element is not found, the function will return without performing any action.\n     */\n    static removeChilds(selector) {\n        const parent = typeof (selector) === \"string\" ? DathorHelpers.get(selector) : selector;\n        if (!parent)\n            return;\n        while (parent.firstChild) {\n            parent.firstChild.remove();\n        }\n    }\n    /**\n     * Creates an HTML element or uses an existing one, and optionally sets its text content.\n     *\n     * @template T - The type of the HTML element.\n     * @param {string | T} p - The tag name of the element to create, or an existing HTML element.\n     * @param {string} [textContent] - Optional text content to set for the element.\n     * @returns {T} The created or provided HTML element with the optional text content set.\n     */\n    static create(p, textContent) {\n        let node;\n        typeof (p) === \"string\" ? node = document.createElement(p) : node = p;\n        if (textContent)\n            node.textContent = textContent;\n        return node;\n    }\n    /**\n     * Converts an HTML string into a DOM element or a DocumentFragment.\n     *\n     * If the provided HTML string contains a single root element, returns that element as an `HTMLElement`.\n     * If the HTML string contains multiple root elements, returns a `DocumentFragment` containing all elements.\n     *\n     * @param html - The HTML string to convert into DOM nodes.\n     * @returns The resulting `HTMLElement` if a single root element is present, or a `DocumentFragment` if multiple elements are present.\n     */\n    static toDOM(html) {\n        const template = document.createElement('template');\n        template.innerHTML = html.trim();\n        if (template.content.childElementCount === 1) {\n            return template.content.firstElementChild;\n        }\n        else {\n            return template.content;\n        }\n    }\n    /**\n     * Traverses up the DOM tree from the given element until it finds an ancestor that matches the specified selector.\n     *\n     * @param element - The starting element from which to begin the traversal.\n     * @param selector - The CSS selector to match the ancestor elements against.\n     * @returns The first ancestor element that matches the selector, or `null` if no matching ancestor is found.\n     */\n    static parentUntil(element, selector) {\n        let currentElement = element;\n        while (currentElement) {\n            if (currentElement.matches(selector)) {\n                return currentElement;\n            }\n            currentElement = currentElement.parentElement;\n        }\n        return null;\n    }\n    /**\n     * Converts an HTMLElement or Element to a CSS selector string.\n     *\n     * @param el - The HTMLElement or Element to convert.\n     * @returns The CSS selector string representing the element's path.\n     * @throws {Error} If the provided argument is not an HTMLElement.\n     */\n    static ElementToSelector(el) {\n        if (!(el instanceof HTMLElement)) {\n            throw new Error('Invalid argument: el must be an HTMLElement');\n        }\n        let path = [];\n        while (el.nodeType === Node.ELEMENT_NODE) {\n            let selector = el.nodeName.toLowerCase();\n            if (el.id) {\n                selector += '#' + el.id;\n                path.unshift(selector);\n                break;\n            }\n            else {\n                let sib = el, nth = 1;\n                while (sib.previousElementSibling) {\n                    sib = sib.previousElementSibling;\n                    nth++;\n                }\n                if (nth !== 1) {\n                    selector += ':nth-child(' + nth + ')';\n                }\n                path.unshift(selector);\n            }\n            el = el.parentNode;\n        }\n        return path.join(' > ');\n    }\n    /**\n     * Retrieves the next sibling element of the given element.\n     *\n     * @param el - The element or a string representing the element's ID.\n     * @returns The next sibling element if it exists and is an HTMLElement, otherwise null.\n     */\n    static nextSibling(el) {\n        const element = typeof el === \"string\" ? DathorHelpers.get(el) : el;\n        return element && element.nextElementSibling instanceof HTMLElement ? element.nextElementSibling : null;\n    }\n    /**\n     * Retrieves the previous sibling of a given HTML element.\n     *\n     * @param el - The target element or a string representing the element's ID.\n     * @returns The previous sibling element if it exists and is an HTMLElement, otherwise null.\n     */\n    static previousSibling(el) {\n        const element = typeof el === \"string\" ? DathorHelpers.get(el) : el;\n        return element && element.previousElementSibling instanceof HTMLElement ? element.previousElementSibling : null;\n    }\n    /**\n     * Gets or sets a data attribute on an HTML element.\n     *\n     * @param el - The target element or a selector string to find the element.\n     * @param key - The data attribute key (without the \"data-\" prefix).\n     * @param value - The value to set for the data attribute. If undefined, the current value is returned. If null, the data attribute is removed.\n     * @returns The current value of the data attribute if getting, or the set value if setting, or undefined if the element is not found.\n     */\n    static data(el, key, value) {\n        const element = typeof el === \"string\" ? DathorHelpers.get(el) : el;\n        if (!element)\n            return undefined;\n        if (value === undefined) {\n            return element.dataset[key];\n        }\n        else if (value === null) {\n            delete element.dataset[key];\n        }\n        else {\n            element.dataset[key] = value;\n        }\n        return value;\n    }\n    /**\n     * Finds the closest ancestor of the given element that matches the specified selector.\n     *\n     * @template T - The type of the HTMLElement.\n     * @param {HTMLElement | string} el - The element or a selector string to start the search from.\n     * @param {string} selector - The selector to match the ancestor against.\n     * @returns {T | null} - The closest matching ancestor element, or null if no match is found.\n     */\n    static closest(el, selector) {\n        const element = typeof el === \"string\" ? DathorHelpers.get(el) : el;\n        return element ? element.closest(selector) : null;\n    }\n    /**\n     * Retrieves the parent element of the given HTML element or element identified by a selector string.\n     *\n     * @param el - The target element or a selector string to identify the element.\n     * @returns The parent HTMLElement of the given element, or null if the element has no parent or does not exist.\n     */\n    static parent(el) {\n        const element = typeof el === \"string\" ? DathorHelpers.get(el) : el;\n        return element ? element.parentElement : null;\n    }\n    /**\n     * Inserts a new HTML element before a reference element in the DOM.\n     *\n     * @param newElement - The new HTML element to be inserted.\n     * @param referenceElement - The reference element before which the new element will be inserted.\n     *                           This can be either an HTMLElement or a string representing the ID of the element.\n     *\n     * @remarks\n     * If the reference element is provided as a string, it will be resolved using `DOMUtils.get`.\n     * If the reference element or its parent node is not found, the new element will not be inserted.\n     */\n    static insertBefore(newElement, referenceElement) {\n        const refEl = typeof referenceElement === \"string\" ? DathorHelpers.get(referenceElement) : referenceElement;\n        if (refEl && refEl.parentNode) {\n            refEl.parentNode.insertBefore(newElement, refEl);\n        }\n    }\n    /**\n     * Inserts a new HTML element immediately after a reference element in the DOM.\n     *\n     * @param newElement - The new HTML element to be inserted.\n     * @param referenceElement - The reference element after which the new element will be inserted.\n     *                           This can be either an HTMLElement or a string representing the ID of the element.\n     *\n     * @remarks\n     * If the reference element is provided as a string, it will be resolved using `DOMUtils.get`.\n     * If the reference element or its parent node is not found, the new element will not be inserted.\n     */\n    static insertAfter(newElement, referenceElement) {\n        const refEl = typeof referenceElement === \"string\" ? DathorHelpers.get(referenceElement) : referenceElement;\n        if (refEl && refEl.parentNode) {\n            refEl.parentNode.insertBefore(newElement, refEl.nextSibling);\n        }\n    }\n    /**\n     * Checks if the given HTML element has the specified class or classes.\n     *\n     * @param element - The HTML element or a string selector to find the element.\n     * @param classNames - The class name or an array of class names to check for.\n     * @returns `true` if the element has all the specified class names, otherwise `false`.\n     */\n    static hasClass(element, classNames) {\n        const el = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!el)\n            return false;\n        if (typeof classNames === \"string\") {\n            return el.classList.contains(classNames);\n        }\n        else if (Array.isArray(classNames)) {\n            return classNames.every(className => el.classList.contains(className));\n        }\n        return false; // Handle invalid input (e.g., non-string, non-array)\n    }\n    /**\n     * Adds one or more class names to the specified HTML element.\n     *\n     * @param element - The target element or a selector string to get the element.\n     * @param classNames - A single class name or an array of class names to add to the element.\n     *\n     * @remarks\n     * If the `element` parameter is a string, it will be used as a selector to find the element.\n     * If the element is not found, the function will return without making any changes.\n     * If the `classNames` parameter is neither a string nor an array, the function will do nothing.\n     *\n     * @example\n     * ```typescript\n     * // Add a single class to an element by selector\n     * addClass(\"#myElement\", \"new-class\");\n     *\n     * // Add multiple classes to an element by reference\n     * const element = document.getElementById(\"myElement\");\n     * addClass(element, [\"class1\", \"class2\"]);\n     * ```\n     */\n    static addClass(element, classNames) {\n        const el = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!el)\n            return;\n        if (typeof classNames === \"string\") {\n            el.classList.add(classNames);\n        }\n        else if (Array.isArray(classNames)) {\n            classNames.forEach(className => el.classList.add(className));\n        } // No else needed: handles invalid input gracefully (does nothing)\n    }\n    /**\n     * Removes one or more class names from the specified HTML element.\n     *\n     * @param element - The target element or a selector string to identify the element.\n     * @param classNames - A single class name or an array of class names to be removed from the element.\n     */\n    static removeClass(element, classNames) {\n        const el = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!el)\n            return;\n        if (typeof classNames === \"string\") {\n            el.classList.remove(classNames);\n        }\n        else if (Array.isArray(classNames)) {\n            classNames.forEach(className => el.classList.remove(className));\n        } // No else needed: handles invalid input gracefully (does nothing)\n    }\n    /**\n     * Toggles one or more class names on the specified element.\n     *\n     * @param element - The target element or a selector string to find the element.\n     * @param classNames - A single class name or an array of class names to toggle.\n     *\n     * @remarks\n     * If the `element` parameter is a string, it will be used as a selector to find the element.\n     * If the `classNames` parameter is a string, it will toggle that single class name.\n     * If the `classNames` parameter is an array, it will toggle each class name in the array.\n     *\n     * @example\n     * ```typescript\n     * // Toggle a single class\n     * toggleClass(document.getElementById('myElement'), 'active');\n     *\n     * // Toggle multiple classes\n     * toggleClass(document.getElementById('myElement'), ['active', 'hidden']);\n     *\n     * // Using a selector string\n     * toggleClass('#myElement', 'active');\n     * ```\n     */\n    static toggleClass(element, classNames) {\n        const el = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!el)\n            return;\n        if (typeof classNames === \"string\") {\n            el.classList.toggle(classNames);\n        }\n        else if (Array.isArray(classNames)) {\n            classNames.forEach(className => el.classList.toggle(className));\n        } // No else needed: handles invalid input gracefully (does nothing)\n    }\n    /**\n     * Sets or gets the inner HTML content of a specified HTML element.\n     *\n     * @param el - The target HTML element or a string selector to identify the element.\n     * @param htmlContent - The HTML content to set. If `undefined`, the current inner HTML is returned.\n     *                      If `null`, the inner HTML is cleared.\n     * @returns The current inner HTML if `htmlContent` is `undefined`, otherwise the new HTML content or `undefined` if the element is not found.\n     */\n    static html(el, htmlContent) {\n        const element = typeof el === \"string\" ? DathorHelpers.get(el) : el;\n        if (!element)\n            return undefined;\n        if (htmlContent === undefined) {\n            return element.innerHTML;\n        }\n        else if (htmlContent === null) {\n            element.innerHTML = '';\n        }\n        else {\n            element.innerHTML = htmlContent;\n        }\n        return htmlContent;\n    }\n    /**\n     * Repeats a template for each item in an array and optionally inserts the result into a container.\n     *\n     * @template T - The type of items in the array.\n     * @param {T[]} items - The array of items to iterate over.\n     * @param {(item: T, index: number) => string} itemTemplate - A function that returns a string template for each item.\n     * @param {HTMLElement | string | null} [container=null] - An optional container (or selector) where the generated HTML will be inserted.\n     * @param {string} [joinString=''] - A string used to join the generated templates.\n     * @returns {void | string} - Returns the generated HTML string if no container is provided or if the container is not found.\n     */\n    static repeat(items, itemTemplate, container = null, joinString = '') {\n        const html = items.map((item, index) => itemTemplate(item, index)).join(joinString);\n        if (container) {\n            const targetContainer = typeof container === \"string\" ? DathorHelpers.get(container) : container;\n            if (targetContainer) {\n                DathorHelpers.html(targetContainer, html);\n                return;\n            }\n            else {\n                return html;\n            }\n        }\n        else {\n            return html;\n        }\n    }\n    /**\n     * Generates a wrapped list of items with optional classes for the wrapper and items.\n     *\n     * @template T - The type of the items in the list.\n     * @param {T[]} items - The array of items to be wrapped.\n     * @param {(item: T, index: number) => string} itemTemplate - A function that returns the HTML string for each item.\n     * @param {string} wrapperTag - The HTML tag to use for the wrapper (e.g., 'ul', 'ol', 'div').\n     * @param {string} [wrapperClass] - Optional CSS class for the wrapper element.\n     * @param {string} [itemClass] - Optional CSS class for each item element.\n     * @returns {string} The HTML string of the wrapped list.\n     */\n    static wrappedList(items, itemTemplate, wrapperTag, wrapperClass, itemClass) {\n        let listItems = items.map((item, index) => {\n            const itemContent = itemTemplate(item, index);\n            if (itemClass) {\n                return `<${wrapperTag === 'ul' || wrapperTag === 'ol' ? 'li' : 'div'} class=\"${itemClass}\">${itemContent}</${wrapperTag === 'ul' || wrapperTag === 'ol' ? 'li' : 'div'}>`;\n            }\n            else {\n                return itemContent;\n            }\n        }).join('');\n        const wrapperClasses = wrapperClass ? ` class=\"${wrapperClass}\"` : '';\n        return `<${wrapperTag}${wrapperClasses}>${listItems}</${wrapperTag}>`;\n    }\n    /**\n     * Appends a list of items to a container element by generating HTML using a template function.\n     *\n     * @template T - The type of items in the list.\n     * @param {T[]} items - The list of items to be appended.\n     * @param {(item: T, index: number) => string} itemTemplate - A function that generates HTML for each item.\n     * @param {HTMLElement | string} container - The container element or its selector where the items will be appended.\n     * @param {string} [joinString=''] - A string used to join the generated HTML for each item.\n     * @returns {void}\n     */\n    static appendToRepeat(items, itemTemplate, container, joinString = '') {\n        const targetContainer = typeof container === \"string\" ? DathorHelpers.get(container) : container;\n        if (!targetContainer)\n            return;\n        const html = DathorHelpers.repeat(items, itemTemplate, null, joinString);\n        DathorHelpers.html(targetContainer, (targetContainer.innerHTML || '') + html);\n    }\n    /**\n     * Appends a list of items to a specified container element, wrapping each item in a specified HTML tag.\n     *\n     * @template T - The type of the items in the list.\n     * @param {T[]} items - The list of items to be appended.\n     * @param {(item: T, index: number) => string} itemTemplate - A function that returns the HTML string for each item.\n     * @param {HTMLElement | string} container - The container element or its selector where the items will be appended.\n     * @param {string} wrapperTag - The HTML tag used to wrap each item.\n     * @param {string} [wrapperClass] - Optional. The CSS class to be applied to the wrapper tag.\n     * @param {string} [itemClass] - Optional. The CSS class to be applied to each item.\n     * @returns {void}\n     */\n    static appendToWrappedList(items, itemTemplate, container, wrapperTag, wrapperClass, itemClass) {\n        const targetContainer = typeof container === \"string\" ? DathorHelpers.get(container) : container;\n        if (!targetContainer)\n            return;\n        const html = DathorHelpers.wrappedList(items, itemTemplate, wrapperTag, wrapperClass, itemClass);\n        DathorHelpers.html(targetContainer, (targetContainer.innerHTML || '') + html);\n    }\n    /**\n     * Observes changes to an object or array and triggers a callback when changes occur.\n     *\n     * @template T - The type of the data to be observed, which can be an object or an array.\n     * @param {T} data - The data to be observed.\n     * @param {(newData: T) => void} updateCallback - The callback function to be called when the data is updated.\n     * @returns {T} - A proxy object that observes changes to the original data.\n     */\n    static observe(// Allow arrays\n    data, updateCallback) {\n        const handler = {\n            set: (target, property, value) => {\n                target[property] = value;\n                updateCallback(target);\n                return true;\n            },\n        };\n        return new Proxy(data, handler);\n    }\n    /**\n     * Binds a property of a data object to the text content of an HTML element.\n     *\n     * @param data - The data object containing the property to bind.\n     * @param property - The property of the data object to bind to the element's text content.\n     * @param element - The target HTML element or a string selector to find the element.\n     * @param joinString - Optional string to join array elements if the property value is an array. Defaults to ', '.\n     *\n     * @remarks\n     * If the `element` parameter is a string, it will be used as a selector to find the target HTML element.\n     * If the property value is an array, the elements will be joined using the `joinString`.\n     * The function observes changes to the data object and updates the element's text content accordingly.\n     */\n    static bindText(data, property, element, joinString = ', ' // Optional join string for arrays\n    ) {\n        const targetElement = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!targetElement)\n            return;\n        const updateText = (newData) => {\n            const value = newData[property];\n            if (Array.isArray(value)) {\n                targetElement.textContent = value.join(joinString);\n            }\n            else {\n                targetElement.textContent = value;\n            }\n        };\n        const observedData = DathorHelpers.observe(data, updateText);\n        updateText(observedData); // Initial render\n    }\n    /**\n     * Binds a property of a data object to an attribute of a DOM element.\n     *\n     * @param data - The data object containing the property to bind.\n     * @param property - The property of the data object to bind to the element's attribute.\n     * @param element - The target DOM element or a string selector to find the element.\n     * @param attribute - The attribute of the DOM element to bind the property to.\n     *\n     * @remarks\n     * This method observes changes to the specified property of the data object and updates\n     * the specified attribute of the target DOM element accordingly.\n     *\n     * @example\n     * ```typescript\n     * const data = { value: \"example\" };\n     * bindAttribute(data, \"value\", \"#myElement\", \"data-value\");\n     * ```\n     */\n    static bindAttribute(data, property, element, attribute) {\n        const targetElement = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!targetElement)\n            return;\n        const updateAttribute = (newData) => {\n            targetElement.setAttribute(attribute, newData[property]);\n        };\n        const observedData = DathorHelpers.observe(data, updateAttribute);\n        updateAttribute(observedData); // Initial render\n    }\n    /**\n     * Binds a data object to a template and updates a target HTML element with the rendered template.\n     *\n     * @template T - The type of the data object.\n     * @param {T} data - The data object to bind to the template.\n     * @param {string} template - The template string containing placeholders in the format {{property}}.\n     * @param {HTMLElement | string} element - The target HTML element or a string selector for the element where the rendered template will be inserted.\n     * @param {(newData: T) => string} [updateCallback] - An optional callback function that takes the new data and returns a string. Defaults to JSON.stringify.\n     *\n     * @returns {void}\n     */\n    static bindTemplate(data, template, element, updateCallback = (data) => JSON.stringify(data)) {\n        const targetElement = typeof element === \"string\" ? DathorHelpers.get(element) : element;\n        if (!targetElement)\n            return;\n        const render = (newData) => {\n            const renderedTemplate = template.replace(/{{(.*?)}}/g, (match, prop) => {\n                return newData[prop.trim()];\n            });\n            targetElement.innerHTML = renderedTemplate;\n        };\n        const observedData = DathorHelpers.observe(data, render);\n        render(observedData); // Initial render\n    }\n    /**\n     * Observes all properties of an object, including nested objects, and triggers a callback when any property changes.\n     *\n     * @template T - The type of the object to observe.\n     * @param {T} data - The object to observe.\n     * @param {(newData: T) => void} updateCallback - The callback function to trigger when the object or any nested object changes.\n     * @returns {T} - The observed object with all properties being watched for changes.\n     */\n    static observeAll(data, updateCallback) {\n        const observedData = this.observe(data, updateCallback);\n        const observeNested = (obj) => {\n            if (typeof obj === 'object' && obj !== null) {\n                for (const key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        if (typeof obj[key] === 'object' && obj[key] !== null) {\n                            obj[key] = DathorHelpers.observe(obj[key], updateCallback);\n                            observeNested(obj[key]);\n                        }\n                    }\n                }\n            }\n        };\n        observeNested(observedData);\n        return observedData;\n    }\n}\nconst $D = DathorHelpers;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DathorHelpers);\n\n\n//# sourceURL=webpack://dathor-helpers/./dist/helpers/all.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/ExampleApp/MyApp.js");
/******/ 	
/******/ })()
;